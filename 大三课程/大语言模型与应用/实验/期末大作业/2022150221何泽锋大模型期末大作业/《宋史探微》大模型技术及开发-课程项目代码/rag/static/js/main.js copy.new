// å…¨å±€å˜é‡
let chatState = {
    isActive: false,
    messages: [],
    currentQuestion: '',
    contexts: []
};
let currentConversationId = null;
let conversations = [];
let progressMessages = [null, '', '', '', ''];
let maxStepReached = 0;
let currentStep = 0;
let finalAnswer = '';
let lastQuestion = '';
let lastAnswer = '';
let lastCreatedAt = '';
let selectedKbFiles = new Set();
let kbEditMode = false;
let editMode = false;
let selectedIds = [];
let sidebarCollapsed = false;

// è¾…åŠ©å‡½æ•°
function cleanWebPageNoise(md) {
    if (!md) return '';
    // 1. ç§»é™¤æ‰€æœ‰å•ç‹¬ä¸€è¡Œçš„æ ‡é¢˜ï¼ˆ#ã€##ã€###ç­‰ï¼‰
    md = md.replace(/^#{1,6} .+$/gm, '');
    // 2. ç§»é™¤å¸¸è§æ ç›®/å¯¼èˆª/å¹¿å‘Šç­‰çŸ­è¡Œ
    const navWords = [
        'é¦–é¡µ', 'ä¸“é¢˜', 'ç™¾ç§‘', 'å†ç°å†å²', 'ç”Ÿæ´»', 'è¯´å‰§', 'è‹±æ–‡ç‰ˆ', 'å†å²è¯é¢˜', 'MILITARY TOPIC', 'æ¢å¯»å†å²é£äº‘æ—§äº‹',
        'äººç‰©', 'å½±è§†', 'è§£æ¢¦', 'ç™¾å®¶å§“', 'æˆè¯­', 'æ˜æ˜Ÿ', 'å†å²', 'æ•™è‚²', 'ä¸‰å›½', 'æ–°é—»', 'æ‰‹æœºç‰ˆ'
    ];
    navWords.forEach(word => {
        // ç§»é™¤å•ç‹¬ä¸€è¡Œçš„æ ç›®è¯
        md = md.replace(new RegExp('^' + word + '\\s*$', 'gm'), '');
    });
    // 3. ç§»é™¤å…¨å¤§å†™çš„çŸ­è¡Œ
    md = md.replace(/^[A-Z\\s]{3,30}$/gm, '');
    // 4. ç§»é™¤"|"åˆ†éš”çš„å¯¼èˆªè¡Œ
    md = md.replace(/^[\\w\\u4e00-\\u9fa5\\s\\|]{5,40}$/gm, function(line) {
        // åªä¿ç•™å«æœ‰"|"ä¸”å…¨ä¸ºæ ç›®è¯çš„è¡Œ
        if (line.includes('|')) return '';
        return line;
    });
    // 5. ç§»é™¤å¤šä½™ç©ºè¡Œ
    md = md.replace(/\\n{2,}/g, '\\n\\n');
    // 6. ç§»é™¤å¼€å¤´å’Œç»“å°¾çš„ç©ºç™½
    md = md.trim();
    return md;
}

function cleanMarkdownHeadings(md) {
    return md.replace(/^#{1,2} (.*)$/gm, '### $1');
}

function truncateMarkdownContent(md, maxLen = 400) {
    if (!md) return '';
    if (md.length <= maxLen) return marked.parse(md);
    const short = md.slice(0, maxLen);
    const id = 'expand-' + Math.random().toString(36).slice(2, 10);
    return `
        <div>
            <div id="${id}-short">${marked.parse(short)}<span style="color:#38bdf8;cursor:pointer;" onclick="document.getElementById('${id}-short').style.display='none';document.getElementById('${id}-full').style.display='block';">[å±•å¼€]</span></div>
            <div id="${id}-full" style="display:none;">${marked.parse(md)}<span style="color:#38bdf8;cursor:pointer;" onclick="document.getElementById('${id}-full').style.display='none';document.getElementById('${id}-short').style.display='block';">[æ”¶èµ·]</span></div>
        </div>
    `;
}

// ä¸»è¦åŠŸèƒ½å‡½æ•°
function updateProgress(step, message) {
    currentStep = step;
    if (step > maxStepReached) maxStepReached = step;
    const progressBar = document.getElementById('progress-bar');
    progressBar.style.width = `${step * 25}%`;

    const steps = document.querySelectorAll('.step');
    steps.forEach((s, i) => {
        if (i < step - 1) {
            s.classList.add('completed');
            s.classList.remove('active');
        } else if (i === step - 1) {
            s.classList.add('active');
            s.classList.remove('completed');
        } else {
            s.classList.remove('active', 'completed');
        }
    });

    const contents = document.querySelectorAll('.progress-content');
    contents.forEach((c, idx) => {
        c.classList.remove('active');
        if (idx === step - 1) {
            c.classList.add('active');
            c.querySelector('.content-body').innerHTML = message;
        } else if (progressMessages[idx + 1]) {
            c.querySelector('.content-body').innerHTML = progressMessages[idx + 1];
        }
    });
}

function showStepContent(stepNumber) {
    const steps = document.querySelectorAll('.step');
    const contents = document.querySelectorAll('.progress-content');
    const progressBar = document.getElementById('progress-bar');

    steps.forEach((step, index) => {
        if (index === stepNumber - 1) {
            step.classList.add('active');
        } else {
            step.classList.remove('active');
        }
        if (index < stepNumber - 1) {
            step.classList.add('completed');
        } else {
            step.classList.remove('completed');
        }
    });

    contents.forEach((content, idx) => {
        content.classList.remove('active');
        if (idx === stepNumber - 1) {
            content.classList.add('active');
        }
    });

    progressBar.style.width = `${stepNumber * 25}%`;
}

async function processQuestion(question) {
    try {
        // Step 1: é—®é¢˜æ¥æ”¶
        progressMessages[1] = `å·²æ¥æ”¶åˆ°æ‚¨çš„é—®é¢˜ï¼š<br><b>${question}</b><br>æ­£åœ¨å¼€å§‹å¤„ç†...`;
        updateProgress(1, progressMessages[1]);
        maxStepReached = 1;

        // Step 2: æ–‡æ¡£æ£€ç´¢
        const customUrl = document.getElementById('custom-url-input').value.trim();
        const searchMode = document.getElementById('search-mode').value;
        const enableWebSearch = document.getElementById('enable-web-search');
        const maxIterations = document.getElementById('max-iterations');

        const retrievalResponse = await fetch('/api/retrieve', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                question,
                enable_web_search: enableWebSearch.checked,
                max_iterations: parseInt(maxIterations.value),
                custom_url: customUrl,
                search_mode: searchMode
            })
        });

        if (!retrievalResponse.ok) throw new Error('æ£€ç´¢å¤±è´¥');
        const contexts = await retrievalResponse.json();
        let retrievalContent = "æ£€ç´¢åˆ°çš„ç›¸å…³å†…å®¹ï¼š<br><br>";
        
        contexts.forEach((ctx, idx) => {
            let typeLabel = '';
            if (ctx.type === 'æŒ‡å®šç½‘é¡µ') {
                typeLabel = `<span style="color:#38bdf8;font-weight:bold;">ã€æŒ‡å®šç½‘é¡µã€‘</span> `;
            } else if (ctx.type === 'ç½‘ç»œæ¥æº') {
                typeLabel = `<span style="color:#4ade80;">ã€è”ç½‘æ£€ç´¢ã€‘</span> `;
            } else {
                typeLabel = `<span style="color:#fbbf24;">ã€æœ¬åœ°æ–‡æ¡£ã€‘</span> `;
            }

            let title = ctx.title ? `<b>${ctx.title}</b> ` : '';
            let url = (ctx.type === 'æŒ‡å®šç½‘é¡µ' || ctx.type === 'ç½‘ç»œæ¥æº') && ctx.url
                ? `<a href="${ctx.url}" target="_blank" style="color:#38bdf8;text-decoration:underline;">${ctx.url}</a><br>`
                : '';

            let contentHtml;
            if (ctx.type === 'æŒ‡å®šç½‘é¡µ') {
                let cleaned = cleanWebPageNoise(ctx.content || '');
                cleaned = cleanMarkdownHeadings(cleaned);
                contentHtml = truncateMarkdownContent(cleaned, 400);
            } else {
                contentHtml = marked.parse(ctx.content ? ctx.content.substring(0, 200) : '');
            }

            retrievalContent += `${idx + 1}. ${typeLabel}${title}${url}${contentHtml}<br><br>`;
        });

        progressMessages[2] = retrievalContent;
        updateProgress(2, progressMessages[2]);
        maxStepReached = 2;

        await new Promise(resolve => setTimeout(resolve, 2000));

        // Step 3: ç”Ÿæˆç­”æ¡ˆï¼ˆæµå¼è¾“å‡ºï¼‰
        progressMessages[3] = `<b>ç”Ÿæˆçš„ç­”æ¡ˆï¼š</b><br><span id='streaming-answer'></span>`;
        updateProgress(3, progressMessages[3]);
        maxStepReached = 3;

        const response = await fetch('/api/generate_stream', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ question, contexts })
        });

        const reader = response.body.getReader();
        let decoder = new TextDecoder();
        let resultText = '';
        let streamingAnswer = document.getElementById('streaming-answer');
        const answerSection = document.querySelector('.answer-section');

        while (true) {
            const { done, value } = await reader.read();
            if (done) break;
            const chunk = decoder.decode(value, { stream: true });
            resultText += chunk;
            if (streamingAnswer) streamingAnswer.innerHTML = marked.parse(resultText);
            if (answerSection) answerSection.innerHTML = marked.parse(resultText);
        }

        finalAnswer = resultText;
        progressMessages[3] = `<b>ç”Ÿæˆçš„ç­”æ¡ˆï¼š</b><br>${marked.parse(finalAnswer)}`;
        updateProgress(3, progressMessages[3]);
        if (answerSection) answerSection.innerHTML = marked.parse(finalAnswer);

        // Step 4: å†²çªæ£€æµ‹
        progressMessages[4] = `<b>å†²çªæ£€æµ‹æ€»ç»“ï¼š</b><br><span id='streaming-conflict'>æ­£åœ¨ç­‰å¾…å†²çªæ£€æµ‹ç»“æœ...<span class='loading-dots'></span></span>`;
        updateProgress(4, progressMessages[4]);
        maxStepReached = 4;

        const conflictResponse = await fetch('/api/conflict_stream', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ contexts })
        });

        const conflictReader = conflictResponse.body.getReader();
        let conflictDecoder = new TextDecoder();
        let conflictText = '';
        let streamingConflict = document.getElementById('streaming-conflict');
        let firstChunk = true;

        try {
            while (true) {
                const { done, value } = await conflictReader.read();
                if (done) break;
                const chunk = conflictDecoder.decode(value, { stream: true });
                conflictText += chunk;
                if (streamingConflict) {
                    if (firstChunk) {
                        streamingConflict.innerHTML = '';
                        firstChunk = false;
                    }
                    streamingConflict.innerHTML = marked.parse(conflictText);
                }
            }
        } catch (e) {
            console.error('å†²çªæ£€æµ‹æµå¼è¾“å‡ºé”™è¯¯:', e);
            if (streamingConflict) {
                streamingConflict.innerHTML = '<span style="color:#fbbf24;">âš ï¸ å†²çªæ£€æµ‹è¿‡ç¨‹ä¸­å‡ºç°é”™è¯¯ï¼Œä½†ä¸ä¼šå½±å“æœ€ç»ˆç­”æ¡ˆçš„ç”Ÿæˆã€‚</span>';
            }
            conflictText = 'å†²çªæ£€æµ‹è¿‡ç¨‹ä¸­å‡ºç°é”™è¯¯ï¼Œä½†ä¸ä¼šå½±å“æœ€ç»ˆç­”æ¡ˆçš„ç”Ÿæˆã€‚';
        }

        if (streamingConflict && (!conflictText || conflictText.trim() === '')) {
            streamingConflict.innerHTML = '<span style="color:#38bdf8;">æœªæ£€æµ‹åˆ°æ˜æ˜¾å†²çªã€‚</span>';
            conflictText = 'æœªæ£€æµ‹åˆ°æ˜æ˜¾å†²çªã€‚';
        }

        const result = {
            answer: finalAnswer,
            sources: contexts,
            hasConflicts: /æœ‰å†²çª/.test(conflictText),
            conflict_reason: conflictText,
            injected_prompt: ''
        };

        if (!result || !Array.isArray(result.sources)) {
            result.sources = [];
        } else if (Array.isArray(result.sources[0])) {
            result.sources = result.sources.flat();
        }
        result.sources = result.sources.filter(item => item && typeof item === 'object');
        return result;
    } catch (error) {
        throw error;
    }
}

function displayResult(result) {
    try {
        console.log('displayResultæ”¶åˆ°çš„result:', result);
        if (!result || !Array.isArray(result.sources)) {
            result.sources = [];
        } else if (Array.isArray(result.sources[0])) {
            result.sources = result.sources.flat();
        }
        result.sources = result.sources.filter(item => item && typeof item === 'object');

        const resultPlaceholder = document.getElementById('result-placeholder');
        const resultContent = document.getElementById('result-content');
        resultPlaceholder.style.display = 'none';
        resultContent.style.display = 'block';

        // æŠ˜å ä¸Šä¸€æ¬¡ç»“æœåˆ°å†å²åŒº
        if (lastQuestion && lastAnswer) {
            const historySection = document.getElementById('history-section');
            const historyId = 'history-local-' + Date.now();
            let createdAt = '';
            if (lastCreatedAt) {
                const dateObj = new Date(lastCreatedAt.replace(' ', 'T').replace(/-/g, '/'));
                createdAt = dateObj.toLocaleString('zh-CN', { hour12: false });
                if (createdAt.startsWith('æ—¶é—´ï¼š')) {
                    createdAt = createdAt.replace(/^æ—¶é—´ï¼š/, '');
                }
            }

            const html = `
                <div class="history-item" style="margin-bottom:8px;">
                    <div class="history-header" style="cursor:pointer;background:#22344a;padding:10px;border-radius:6px;" onclick="const b=document.getElementById('${historyId}-body');b.style.display=b.style.display==='none'?'block':'none'">
                        <b>å†å²æé—®ï¼š</b> ${lastQuestion.replace(/</g,'&lt;').replace(/>/g,'&gt;').slice(0,60)} <span style="color:#38bdf8;">[ç‚¹å‡»å±•å¼€/æ”¶èµ·]</span>
                    </div>
                    <div class="history-body" id="${historyId}-body" style="display:none;background:#1a2533;padding:12px;border-radius:6px;">
                        <b>é—®é¢˜ï¼š</b> ${lastQuestion.replace(/</g,'&lt;').replace(/>/g,'&gt;')}<br><b>ç­”æ¡ˆï¼š</b><br>${marked.parse(lastAnswer||'')}
                        <div style="color:#888;font-size:0.92em;margin-top:6px;">${createdAt ? 'æ—¶é—´ï¼š' + createdAt : ''}</div>
                    </div>
                </div>
            `;
            historySection.insertAdjacentHTML('afterbegin', html);
        }

        // è®°å½•æœ¬æ¬¡é—®é¢˜å’Œç­”æ¡ˆ
        lastQuestion = '';
        lastAnswer = '';
        if (
            result.sources &&
            result.sources.length &&
            typeof result.sources[0] === 'object' &&
            result.sources[0] !== null &&
            'question' in result.sources[0]
        ) {
            lastQuestion = result.sources[0].question;
        } else if (window.currentQuestion) {
            lastQuestion = window.currentQuestion;
        }
        lastAnswer = result.answer || '';
        lastCreatedAt = result.created_at;

        // Display answer
        const answerSection = resultContent.querySelector('.answer-section');
        answerSection.innerHTML = marked.parse(result.answer || '');

        // Display sources
        const sourcesList = resultContent.querySelector('.sources-list');
        sourcesList.innerHTML = '';
        (result.sources || []).forEach(source => {
            const sourceElement = document.createElement('div');
            sourceElement.className = 'source-item';

            let typeLabel = '';
            let icon = '';
            let urlHtml = '';
            let title = source.title ? `<b>${source.title}</b><br>` : '';

            if (source.type === 'æŒ‡å®šç½‘é¡µ') {
                typeLabel = `<span style="color:#38bdf8;font-weight:bold;">ğŸŒ æŒ‡å®šç½‘é¡µ</span>`;
                icon = 'ğŸŒ';
                if (source.url) {
                    urlHtml = `<div style="margin-top:4px;"><a href="${source.url}" target="_blank" style="color:#38bdf8;text-decoration:underline;">${source.url}</a></div>`;
                }
            } else if (source.type === 'ç½‘ç»œæ¥æº') {
                typeLabel = `<span style="color:#4ade80;">ğŸŒ è”ç½‘æ£€ç´¢</span>`;
                icon = 'ğŸŒ';
                if (source.url) {
                    urlHtml = `<div style="margin-top:4px;"><a href="${source.url}" target="_blank" style="color:#38bdf8;text-decoration:underline;">${source.url}</a></div>`;
                }
            } else {
                typeLabel = `<span style="color:#fbbf24;">ğŸ“„ æœ¬åœ°æ–‡æ¡£</span>`;
                icon = 'ğŸ“„';
            }

            let contentHtml;
            if (source.type === 'æŒ‡å®šç½‘é¡µ') {
                let cleaned = cleanWebPageNoise(source.content || '');
                cleaned = cleanMarkdownHeadings(cleaned);
                contentHtml = truncateMarkdownContent(cleaned, 400);
            } else {
                contentHtml = marked.parse(source.content || '');
            }

            sourceElement.innerHTML = `
                <div class="source-type">${typeLabel}</div>
                <div class="source-content">
                    ${title}
                    ${contentHtml}
                    ${urlHtml}
                </div>
            `;
            sourcesList.appendChild(sourceElement);
        });

        // Display conflict warning if needed
        if (result.hasConflicts) {
            const warningElement = document.createElement('div');
            warningElement.className = 'conflict-warning';
            warningElement.innerHTML = `
                <i class="fas fa-exclamation-triangle"></i>
                <p>æ£€æµ‹åˆ°ä¸åŒæ¥æºçš„ä¿¡æ¯å­˜åœ¨æ½œåœ¨å†²çªï¼Œè¯·æ³¨æ„ç”„åˆ«ã€‚</p>
                <div style='margin-top:8px; color:#fbbf24; font-size:0.98rem;'><b>å†²çªæ£€æµ‹æ¨ç†è¿‡ç¨‹ï¼š</b><br>${marked.parse(result.conflict_reason || '')}</div>
            `;
            resultContent.appendChild(warningElement);
        }
    } catch (e) {
        console.error('åˆ†æç»“æœæ¸²æŸ“å¼‚å¸¸:', e, result);
        alert('åˆ†æç»“æœæ¸²æŸ“å¼‚å¸¸ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•\n' + e.message);
    }
}

// é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
document.addEventListener('DOMContentLoaded', async () => {
    try {
        console.log('é¡µé¢å¼€å§‹åŠ è½½...');
        
        // åˆå§‹åŒ–å¯¹è¯çŠ¶æ€
        chatState = {
            messages: [],
            isActive: false
        };
        
        // åŠ è½½å†å²å¯¹è¯è®°å½•
        console.log('å¼€å§‹è·å–å¯¹è¯åˆ—è¡¨...');
        const response = await fetch('/api/conversations');
        console.log('è·å–åˆ°å“åº”:', response.status);
        
        if (!response.ok) {
            throw new Error('è·å–å¯¹è¯åˆ—è¡¨å¤±è´¥');
        }
        
        const conversations = await response.json();
        console.log('è·å–åˆ°å¯¹è¯åˆ—è¡¨:', conversations);
        
        // å¦‚æœæ²¡æœ‰å¯¹è¯è®°å½•ï¼Œåˆ›å»ºä¸€ä¸ªæµ‹è¯•å¯¹è¯
        if (conversations.length === 0) {
            console.log('æ²¡æœ‰å¯¹è¯è®°å½•ï¼Œåˆ›å»ºæµ‹è¯•å¯¹è¯...');
            const testResponse = await fetch('/api/conversations', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    id: 'test-' + Date.now(),
                    title: 'æµ‹è¯•å¯¹è¯'
                })
            });
            
            if (testResponse.ok) {
                console.log('æµ‹è¯•å¯¹è¯åˆ›å»ºæˆåŠŸ');
                // é‡æ–°åŠ è½½å¯¹è¯åˆ—è¡¨
                const newResponse = await fetch('/api/conversations');
                if (newResponse.ok) {
                    const newConversations = await newResponse.json();
                    conversations.push(...newConversations);
                }
            }
        }
        
        // æ›´æ–°å¯¹è¯åˆ—è¡¨
        const conversationList = document.getElementById('conversation-list');
        if (!conversationList) {
            console.error('æ‰¾ä¸åˆ°å¯¹è¯åˆ—è¡¨å…ƒç´ ');
            return;
        }
        
        conversationList.innerHTML = '';
        
        if (conversations.length === 0) {
            console.log('æ²¡æœ‰æ‰¾åˆ°ä»»ä½•å¯¹è¯è®°å½•');
            const emptyMessage = document.createElement('div');
            emptyMessage.className = 'empty-message';
            emptyMessage.textContent = 'æš‚æ— å¯¹è¯è®°å½•';
            conversationList.appendChild(emptyMessage);
        } else {
            conversations.forEach(conv => {
                console.log('å¤„ç†å¯¹è¯:', conv);
                const conversationItem = document.createElement('div');
                conversationItem.className = 'conversation-item';
                conversationItem.dataset.id = conv.id;
                
                const title = document.createElement('div');
                title.className = 'conversation-title';
                title.textContent = conv.title || 'æ–°å¯¹è¯';
                
                const time = document.createElement('div');
                time.className = 'conversation-time';
                time.textContent = new Date(conv.created_at).toLocaleString();
                
                conversationItem.appendChild(title);
                conversationItem.appendChild(time);
                
                conversationItem.addEventListener('click', () => loadConversation(conv.id));
                conversationList.appendChild(conversationItem);
            });
        }
        
        // åˆå§‹åŒ–äº‹ä»¶ç›‘å¬
        initializeEventListeners();
        
        // èšç„¦åˆ°è¾“å…¥æ¡†
        const questionInput = document.getElementById('question-input');
        if (questionInput) {
            questionInput.focus();
        }
        
        console.log('é¡µé¢åˆå§‹åŒ–å®Œæˆ');
    } catch (error) {
        console.error('åˆå§‹åŒ–å¤±è´¥:', error);
    }
});

// åˆå§‹åŒ–äº‹ä»¶ç›‘å¬å™¨
function initializeEventListeners() {
    // æé—®æŒ‰é’®ç‚¹å‡»äº‹ä»¶
    const askButton = document.getElementById('ask-button');
    const questionInput = document.getElementById('question-input');
    
    if (askButton && questionInput) {
        askButton.addEventListener('click', async () => {
            const question = questionInput.value.trim();
            if (!question) return;

            // å¦‚æœæ²¡æœ‰å½“å‰å¯¹è¯ï¼Œåˆ›å»ºæ–°å¯¹è¯
            if (!currentConversationId) {
                currentConversationId = 'conv-' + Date.now();
                const newConversation = {
                    id: currentConversationId,
                    title: question.slice(0, 30) + (question.length > 30 ? '...' : ''),
                    created_at: new Date().toISOString()
                };
                
                try {
                    const response = await fetch('/api/conversations', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(newConversation)
                    });
                    
                    if (!response.ok) {
                        throw new Error('åˆ›å»ºå¯¹è¯å¤±è´¥');
                    }
                    
                    await loadConversations();
                } catch (error) {
                    console.error('ä¿å­˜å¯¹è¯å¤±è´¥:', error);
                    return;
                }
            }

            // ç¦ç”¨è¾“å…¥å’ŒæŒ‰é’®
            questionInput.disabled = true;
            askButton.disabled = true;
            askButton.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';

            try {
                // æ·»åŠ ç”¨æˆ·æ¶ˆæ¯åˆ°ç•Œé¢
                addChatMessage('user', question);
                
                // æ›´æ–°å¯¹è¯çŠ¶æ€
                chatState.messages.push({ role: 'user', content: question });
                
                // å‘é€åˆ°åç«¯
                const response = await fetch('/api/chat', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        message: question,
                        chat_history: chatState.messages,
                        conversation_id: currentConversationId
                    })
                });

                if (!response.ok) {
                    throw new Error('å¯¹è¯è¯·æ±‚å¤±è´¥');
                }

                const result = await response.json();
                
                // æ·»åŠ AIå›å¤åˆ°ç•Œé¢
                addChatMessage('assistant', result.message);
                
                // æ›´æ–°å¯¹è¯çŠ¶æ€
                chatState.messages.push({ role: 'assistant', content: result.message });
                
                // å¦‚æœå¯¹è¯å®Œæˆï¼Œè¿›å…¥æ£€ç´¢é˜¶æ®µ
                if (result.status === 'complete') {
                    // æ¸…ç©ºåˆ†æç»“æœåŒº
                    const resultPlaceholder = document.getElementById('result-placeholder');
                    const resultContent = document.getElementById('result-content');
                    resultPlaceholder.style.display = 'block';
                    resultContent.style.display = 'none';
                    const answerSection = document.querySelector('.answer-section');
                    if (answerSection) answerSection.innerHTML = '';
                    const sourcesList = document.querySelector('.sources-list');
                    if (sourcesList) sourcesList.innerHTML = '';
                    document.querySelectorAll('.conflict-warning').forEach(el => el.remove());

                    // ç»§ç»­å¤„ç†æ£€ç´¢å’Œç”Ÿæˆ
                    const finalResult = await processQuestion(question);
                    displayResult(finalResult);
                }
                
                // é‡ç½®è¾“å…¥æ¡†çŠ¶æ€
                questionInput.value = '';
                questionInput.disabled = false;
                questionInput.focus();
                askButton.disabled = false;
                askButton.innerHTML = '<i class="fas fa-paper-plane"></i>';
                
            } catch (error) {
                console.error('å¯¹è¯å¤±è´¥:', error);
                const errorMessage = 'æŠ±æ­‰ï¼Œå¯¹è¯å‡ºç°é”™è¯¯ï¼Œè¯·é‡è¯•';
                addChatMessage('system', errorMessage);
                questionInput.disabled = false;
                askButton.disabled = false;
                askButton.innerHTML = '<i class="fas fa-paper-plane"></i>';
            }
        });

        // è¾“å…¥æ¡†å›è½¦äº‹ä»¶
        questionInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                askButton.click();
            }
        });
    }

    // æ ‡ç­¾é¡µåˆ‡æ¢
    const historyTabBtn = document.getElementById('history-tab-btn');
    const knowledgeTabBtn = document.getElementById('knowledge-tab-btn');
    const historyPanel = document.getElementById('history-panel');
    const knowledgePanel = document.getElementById('knowledge-panel');

    if (historyTabBtn && knowledgeTabBtn && historyPanel && knowledgePanel) {
        historyTabBtn.onclick = () => switchTab('history');
        knowledgeTabBtn.onclick = () => switchTab('knowledge');
    }

    // ä¾§è¾¹æ æ”¶ç¼©/å±•å¼€
    const sidebar = document.getElementById('sidebar');
    const toggleBtn = document.getElementById('toggle-sidebar-btn');
    const openSidebarBtn = document.getElementById('open-sidebar-btn');

    if (sidebar && toggleBtn && openSidebarBtn) {
        toggleBtn.onclick = function() {
            sidebarCollapsed = true;
            sidebar.style.width = '0';
            sidebar.style.minWidth = '0';
            sidebar.style.padding = '0';
            sidebar.style.overflow = 'hidden';
            sidebar.style.boxShadow = 'none';
            sidebar.style.borderRadius = '0 16px 16px 0';
            document.getElementById('main-inner').style.paddingLeft = '0';
            toggleBtn.style.display = 'none';
            openSidebarBtn.style.display = 'block';
        };

        openSidebarBtn.onclick = function() {
            sidebarCollapsed = false;
            sidebar.style.width = '320px';
            sidebar.style.minWidth = '220px';
            sidebar.style.padding = '18px 10px 18px 18px';
            sidebar.style.overflow = '';
            sidebar.style.boxShadow = 'var(--glow),2px 0 16px 0 rgba(58,134,255,0.08)';
            sidebar.style.borderRadius = '0 16px 16px 0';
            document.getElementById('main-inner').style.paddingLeft = '320px';
            toggleBtn.style.display = '';
            openSidebarBtn.style.display = 'none';
        };
    }

    // çŸ¥è¯†åº“ç›¸å…³æŒ‰é’®
    const editKbBtn = document.getElementById('edit-kb-btn');
    const cancelKbEditBtn = document.getElementById('cancel-kb-edit-btn');
    const selectAllKbBtn = document.getElementById('select-all-kb-btn');
    const deleteSelectedKbBtn = document.getElementById('delete-selected-kb-btn');
    const refreshKbBtn = document.getElementById('refresh-kb-btn');
    const fileUpload = document.getElementById('file-upload');

    if (editKbBtn) {
        editKbBtn.onclick = () => setKbEditMode(true);
    }
    if (cancelKbEditBtn) {
        cancelKbEditBtn.onclick = () => {
            setKbEditMode(false);
            selectedKbFiles.clear();
        };
    }
    if (selectAllKbBtn) {
        selectAllKbBtn.onclick = function() {
            const checkboxes = document.querySelectorAll('.kb-file-checkbox');
            const allChecked = Array.from(checkboxes).every(cb => cb.checked);
            
            checkboxes.forEach(cb => {
                const filename = cb.getAttribute('data-filename');
                cb.checked = !allChecked;
                if (!allChecked) {
                    selectedKbFiles.add(filename);
                } else {
                    selectedKbFiles.delete(filename);
                }
            });
        };
    }
    if (deleteSelectedKbBtn) {
        deleteSelectedKbBtn.onclick = async function() {
            if (!selectedKbFiles.size) {
                alert('è¯·å…ˆé€‰æ‹©è¦åˆ é™¤çš„æ–‡ä»¶');
                return;
            }

            if (!confirm('ç¡®å®šè¦åˆ é™¤é€‰ä¸­çš„æ–‡ä»¶å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ¢å¤ã€‚')) return;

            try {
                const response = await fetch('/api/knowledge/delete', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        filenames: Array.from(selectedKbFiles)
                    })
                });

                const result = await response.json();
                
                if (!response.ok) {
                    throw new Error(result.error || 'åˆ é™¤å¤±è´¥');
                }

                if (result.errors && result.errors.length > 0) {
                    alert(`éƒ¨åˆ†æ–‡ä»¶åˆ é™¤æˆåŠŸï¼Œä½†å­˜åœ¨ä»¥ä¸‹é”™è¯¯ï¼š\n${result.errors.join('\n')}`);
                } else {
                    alert('æ–‡ä»¶åˆ é™¤æˆåŠŸ');
                }
                
                selectedKbFiles.clear();
                setKbEditMode(false);
                await renderKnowledgeBase();
                
            } catch (error) {
                console.error('æ–‡ä»¶åˆ é™¤å¤±è´¥:', error);
                alert('æ–‡ä»¶åˆ é™¤å¤±è´¥: ' + error.message);
            }
        };
    }
    if (refreshKbBtn) {
        refreshKbBtn.onclick = renderKnowledgeBase;
    }
    if (fileUpload) {
        fileUpload.addEventListener('change', async function(e) {
            const files = e.target.files;
            if (!files.length) return;

            const formData = new FormData();
            for (let file of files) {
                formData.append('files[]', file, file.name);
            }

            try {
                const response = await fetch('/api/knowledge/upload', {
                    method: 'POST',
                    body: formData
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error || 'ä¸Šä¼ å¤±è´¥');
                }
                
                const result = await response.json();
                if (result.error) throw new Error(result.error);
                
                alert('æ–‡ä»¶ä¸Šä¼ æˆåŠŸ');
                await renderKnowledgeBase();
            } catch (error) {
                console.error('æ–‡ä»¶ä¸Šä¼ å¤±è´¥:', error);
                alert('æ–‡ä»¶ä¸Šä¼ å¤±è´¥: ' + error.message);
            }

            e.target.value = '';
        });
    }

    // æ–°å»ºå¯¹è¯æŒ‰é’®
    const newChatBtn = document.getElementById('new-chat-btn');
    if (newChatBtn) {
        newChatBtn.addEventListener('click', async () => {
            if (currentConversationId && chatState.messages.length > 0) {
                try {
                    const lastMessage = chatState.messages[chatState.messages.length - 1];
                    const title = lastMessage.content.slice(0, 30) + (lastMessage.content.length > 30 ? '...' : '');
                    
                    await fetch(`/api/conversations/${currentConversationId}`, {
                        method: 'PUT',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ title: title })
                    });

                    await loadConversations();
                } catch (error) {
                    console.error('ä¿å­˜å½“å‰å¯¹è¯å¤±è´¥:', error);
                }
            }
            
            currentConversationId = null;
            chatState.messages = [];
            chatState.isActive = false;
            
            const chatMessages = document.getElementById('chat-messages');
            if (chatMessages) {
                chatMessages.innerHTML = '';
            }
            
            if (questionInput) {
                questionInput.value = '';
            }
            
            renderConversations();
            
            if (questionInput) {
                questionInput.focus();
            }
        });
    }
}

// å¯¼å‡ºéœ€è¦çš„å‡½æ•°
export {
    cleanWebPageNoise,
    cleanMarkdownHeadings,
    truncateMarkdownContent,
    processQuestion,
    displayResult,
    updateProgress,
    showStepContent,
    addChatMessage,
    switchConversation,
    renderConversations,
    loadConversations,
    renderHistory,
    setEditMode,
    renderHistoryControls,
    setKbEditMode,
    renderKnowledgeBase,
    initializeEventListeners
}; 