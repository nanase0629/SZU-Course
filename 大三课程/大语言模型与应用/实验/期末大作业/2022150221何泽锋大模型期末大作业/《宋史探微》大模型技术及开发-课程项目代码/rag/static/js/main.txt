// é¡µé¢åˆå§‹åŒ–
document.addEventListener('DOMContentLoaded', async () => {
    // è·å–å†å²è®°å½•
    try {
        const response = await fetch('/api/history');
        const data = await response.json();
        renderHistory(data);
    } catch (error) {
        console.error('è·å–å†å²è®°å½•å¤±è´¥:', error);
    }

    // åˆå§‹åŒ–çŸ¥è¯†åº“
    initKnowledgeBase();

    // æ ‡ç­¾é¡µåˆ‡æ¢é€»è¾‘
    const historyTabBtn = document.getElementById('history-tab-btn');
    const knowledgeTabBtn = document.getElementById('knowledge-tab-btn');
    const historyPanel = document.getElementById('history-panel');
    const knowledgePanel = document.getElementById('knowledge-panel');

    function switchTab(tabName) {
        // æ›´æ–°æŒ‰é’®çŠ¶æ€
        historyTabBtn.classList.toggle('active', tabName === 'history');
        knowledgeTabBtn.classList.toggle('active', tabName === 'knowledge');
        
        // æ›´æ–°é¢æ¿æ˜¾ç¤º
        historyPanel.classList.toggle('active', tabName === 'history');
        knowledgePanel.classList.toggle('active', tabName === 'knowledge');
    }

    historyTabBtn.onclick = () => switchTab('history');
    knowledgeTabBtn.onclick = () => switchTab('knowledge');

    // ä¾§è¾¹æ æ”¶ç¼©/å±•å¼€é€»è¾‘
    const sidebar = document.getElementById('sidebar');
    const toggleBtn = document.getElementById('toggle-sidebar-btn');
    const openSidebarBtn = document.getElementById('open-sidebar-btn');
    let sidebarCollapsed = false;

    toggleBtn.onclick = function() {
        sidebarCollapsed = true;
        sidebar.style.width = '0';
        sidebar.style.minWidth = '0';
        sidebar.style.padding = '0';
        sidebar.style.overflow = 'hidden';
        sidebar.style.boxShadow = 'none';
        sidebar.style.borderRadius = '0 16px 16px 0';
        document.getElementById('main-inner').style.paddingLeft = '0';
        toggleBtn.style.display = 'none';
        openSidebarBtn.style.display = 'block';
    };

    openSidebarBtn.onclick = function() {
        sidebarCollapsed = false;
        sidebar.style.width = '320px';
        sidebar.style.minWidth = '220px';
        sidebar.style.padding = '18px 10px 18px 18px';
        sidebar.style.overflow = '';
        sidebar.style.boxShadow = 'var(--glow),2px 0 16px 0 rgba(58,134,255,0.08)';
        sidebar.style.borderRadius = '0 16px 16px 0';
        document.getElementById('main-inner').style.paddingLeft = '320px';
        toggleBtn.style.display = '';
        openSidebarBtn.style.display = 'none';
    };

    // å¯¹è¯ç®¡ç†ç›¸å…³å˜é‡
    let currentConversationId = null;
    let conversations = [];

    // æ–°å»ºå¯¹è¯
    document.getElementById('new-chat-btn').addEventListener('click', async () => {
        // å¦‚æœå½“å‰æœ‰å¯¹è¯ä¸”æœªä¿å­˜ï¼Œå…ˆä¿å­˜å½“å‰å¯¹è¯
        if (currentConversationId && chatState.messages.length > 0) {
            try {
                // ä¿å­˜å½“å‰å¯¹è¯çš„æœ€åä¸€æ¡æ¶ˆæ¯ä½œä¸ºæ ‡é¢˜
                const lastMessage = chatState.messages[chatState.messages.length - 1];
                const title = lastMessage.content.slice(0, 30) + (lastMessage.content.length > 30 ? '...' : '');
                
                // æ›´æ–°å¯¹è¯æ ‡é¢˜
                await fetch(`/api/conversations/${currentConversationId}`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ title: title })
                });

                // é‡æ–°åŠ è½½å¯¹è¯åˆ—è¡¨
                await loadConversations();
            } catch (error) {
                console.error('ä¿å­˜å½“å‰å¯¹è¯å¤±è´¥:', error);
            }
        }
        
        // æ¸…ç©ºå½“å‰å¯¹è¯çŠ¶æ€
        currentConversationId = null;
        chatState.messages = [];
        chatState.isActive = false;
        
        // æ¸…ç©ºå¯¹è¯æ¡†
        const chatMessages = document.getElementById('chat-messages');
        chatMessages.innerHTML = '';
        
        // æ¸…ç©ºè¾“å…¥æ¡†
        questionInput.value = '';
        
        // æ›´æ–°UI
        renderConversations();
        
        // èšç„¦åˆ°è¾“å…¥æ¡†
        questionInput.focus();
    });

    // æ¸²æŸ“å¯¹è¯åˆ—è¡¨
    function renderConversations() {
        const conversationsList = document.getElementById('conversations-list');
        conversationsList.innerHTML = '';
        
        conversations.forEach(conv => {
            const convDiv = document.createElement('div');
            convDiv.className = `conversation-item ${conv.id === currentConversationId ? 'active' : ''}`;
            convDiv.style.padding = '10px';
            convDiv.style.marginBottom = '5px';
            convDiv.style.cursor = 'pointer';
            convDiv.style.borderRadius = '5px';
            convDiv.style.backgroundColor = conv.id === currentConversationId ? 'rgba(58,134,255,0.1)' : 'transparent';
            convDiv.style.transition = 'background-color 0.2s';
            
            convDiv.onmouseover = () => {
                if (conv.id !== currentConversationId) {
                    convDiv.style.backgroundColor = 'rgba(58,134,255,0.05)';
                }
            };
            convDiv.onmouseout = () => {
                if (conv.id !== currentConversationId) {
                    convDiv.style.backgroundColor = 'transparent';
                }
            };
            
            convDiv.onclick = () => switchConversation(conv.id);
            
            const titleDiv = document.createElement('div');
            titleDiv.style.fontWeight = 'bold';
            titleDiv.style.marginBottom = '5px';
            titleDiv.textContent = conv.title;
            
            const timeDiv = document.createElement('div');
            timeDiv.style.fontSize = '0.8em';
            timeDiv.style.color = '#666';
            timeDiv.textContent = new Date(conv.created_at).toLocaleString();
            
            convDiv.appendChild(titleDiv);
            convDiv.appendChild(timeDiv);
            conversationsList.appendChild(convDiv);
        });
    }

    // åœ¨é¡µé¢åŠ è½½æ—¶è·å–å¯¹è¯åˆ—è¡¨
    async function loadConversations() {
        try {
            const response = await fetch('/api/conversations');
            if (!response.ok) {
                throw new Error('è·å–å¯¹è¯åˆ—è¡¨å¤±è´¥');
            }
            const data = await response.json();
            conversations = data;
            renderConversations();
        } catch (error) {
            console.error('åŠ è½½å¯¹è¯åˆ—è¡¨å¤±è´¥:', error);
        }
    }

    // åœ¨é¡µé¢åŠ è½½å®Œæˆåè·å–å¯¹è¯åˆ—è¡¨
    document.addEventListener('DOMContentLoaded', () => {
        loadConversations();
    });

    // é‡å‘½åå¯¹è¯
    function renameConversation(convId) {
        const conversation = conversations.find(c => c.id === convId);
        if (conversation) {
            const newTitle = prompt('è¯·è¾“å…¥æ–°çš„å¯¹è¯æ ‡é¢˜ï¼š', conversation.title);
            if (newTitle && newTitle.trim()) {
                conversation.title = newTitle.trim();
                renderConversations();
            }
        }
    }

    // åˆ é™¤å¯¹è¯
    function deleteConversation(convId) {
        if (confirm('ç¡®å®šè¦åˆ é™¤è¿™ä¸ªå¯¹è¯å—ï¼Ÿ')) {
            conversations = conversations.filter(c => c.id !== convId);
            if (currentConversationId === convId) {
                currentConversationId = null;
                // æ¸…ç©ºä¸»ç•Œé¢çš„å¯¹è¯
                document.getElementById('chat-messages').innerHTML = '';
                // é‡ç½®çŠ¶æ€
                chatState = {
                    isActive: false,
                    messages: [],
                    currentQuestion: '',
                    contexts: []
                };
            }
            renderConversations();
        }
    }

    let isEditMode = false;
    const selectedConversations = new Set();
    
    // æ·»åŠ ç¼–è¾‘æ¨¡å¼æŒ‰é’®äº‹ä»¶ç›‘å¬
    document.getElementById('edit-mode-btn').addEventListener('click', () => {
        isEditMode = !isEditMode;
        selectedConversations.clear();
        document.getElementById('conversations-list').classList.toggle('edit-mode');
        document.getElementById('batch-actions').style.display = isEditMode ? 'flex' : 'none';
        document.getElementById('edit-mode-btn').innerHTML = isEditMode ? 
            '<i class="fas fa-times"></i> é€€å‡ºç¼–è¾‘' : 
            '<i class="fas fa-edit"></i> ç¼–è¾‘';
        renderConversations();
    });
    
    // æ·»åŠ åˆ é™¤é€‰ä¸­æŒ‰é’®äº‹ä»¶ç›‘å¬
    document.getElementById('delete-selected-btn').addEventListener('click', async () => {
        if (selectedConversations.size === 0) {
            alert('è¯·å…ˆé€‰æ‹©è¦åˆ é™¤çš„å¯¹è¯');
            return;
        }
        
        if (!confirm(`ç¡®å®šè¦åˆ é™¤é€‰ä¸­çš„ ${selectedConversations.size} ä¸ªå¯¹è¯å—ï¼Ÿ`)) {
            return;
        }
        
        try {
            for (const convId of selectedConversations) {
                await fetch(`/api/conversations/${convId}`, {
                    method: 'DELETE'
                });
            }
            
            // å¦‚æœå½“å‰å¯¹è¯è¢«åˆ é™¤ï¼Œæ¸…ç©ºå½“å‰å¯¹è¯
            if (selectedConversations.has(currentConversationId)) {
                currentConversationId = null;
                chatState.messages = [];
                document.getElementById('chat-messages').innerHTML = '';
            }
            
            // é‡æ–°åŠ è½½å¯¹è¯åˆ—è¡¨
            await loadConversations();
            
            // é€€å‡ºç¼–è¾‘æ¨¡å¼
            isEditMode = false;
            selectedConversations.clear();
            document.getElementById('conversations-list').classList.remove('edit-mode');
            document.getElementById('batch-actions').style.display = 'none';
            document.getElementById('edit-mode-btn').innerHTML = '<i class="fas fa-edit"></i> ç¼–è¾‘';
            
        } catch (error) {
            console.error('åˆ é™¤å¯¹è¯å¤±è´¥:', error);
            alert('åˆ é™¤å¯¹è¯å¤±è´¥ï¼Œè¯·é‡è¯•');
        }
    });
    
    // æ·»åŠ å–æ¶ˆç¼–è¾‘æŒ‰é’®äº‹ä»¶ç›‘å¬
    document.getElementById('cancel-edit-btn').addEventListener('click', () => {
        isEditMode = false;
        selectedConversations.clear();
        document.getElementById('conversations-list').classList.remove('edit-mode');
        document.getElementById('batch-actions').style.display = 'none';
        document.getElementById('edit-mode-btn').innerHTML = '<i class="fas fa-edit"></i> ç¼–è¾‘';
        renderConversations();
    });

    // æ·»åŠ å¯¹è¯çŠ¶æ€ç®¡ç†
    let chatState = {
        isActive: false,
        messages: [],
        currentQuestion: '',
        contexts: []
    };

    // ä¿®æ”¹æ·»åŠ æ¶ˆæ¯åˆ°å¯¹è¯ç•Œé¢çš„å‡½æ•°
    function addChatMessage(role, content) {
        const chatMessages = document.getElementById('chat-messages');
        const messageDiv = document.createElement('div');
        messageDiv.className = `chat-message ${role}`;
        messageDiv.style.marginBottom = '10px';
        messageDiv.style.padding = '10px';
        messageDiv.style.borderRadius = '8px';
        messageDiv.style.maxWidth = '80%';
        
        if (role === 'user') {
            messageDiv.style.marginLeft = 'auto';
            messageDiv.style.backgroundColor = 'rgba(58,134,255,0.2)';
        } else if (role === 'assistant') {
            messageDiv.style.marginRight = 'auto';
            messageDiv.style.backgroundColor = 'rgba(42,91,140,0.2)';
        } else {
            messageDiv.style.margin = '5px auto';
            messageDiv.style.backgroundColor = 'rgba(251,191,36,0.2)';
            messageDiv.style.textAlign = 'center';
        }
        
        messageDiv.innerHTML = marked.parse(content);
        chatMessages.appendChild(messageDiv);
        chatMessages.scrollTop = chatMessages.scrollHeight;
    }

    // ä¿®æ”¹æé—®æŒ‰é’®çš„ç‚¹å‡»äº‹ä»¶å¤„ç†
    askButton.addEventListener('click', async () => {
        const question = questionInput.value.trim();
        if (!question) return;

        // å¦‚æœæ²¡æœ‰å½“å‰å¯¹è¯ï¼Œåˆ›å»ºæ–°å¯¹è¯
        if (!currentConversationId) {
            currentConversationId = 'conv-' + Date.now();
            const newConversation = {
                id: currentConversationId,
                title: question.slice(0, 30) + (question.length > 30 ? '...' : ''),
                created_at: new Date().toISOString()
            };
            
            // ä¿å­˜æ–°å¯¹è¯åˆ°æ•°æ®åº“
            try {
                const response = await fetch('/api/conversations', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(newConversation)
                });
                
                if (!response.ok) {
                    throw new Error('åˆ›å»ºå¯¹è¯å¤±è´¥');
                }
                
                // é‡æ–°åŠ è½½å¯¹è¯åˆ—è¡¨
                await loadConversations();
            } catch (error) {
                console.error('ä¿å­˜å¯¹è¯å¤±è´¥:', error);
            return;
            }
        }

        // ç¦ç”¨è¾“å…¥å’ŒæŒ‰é’®
        questionInput.disabled = true;
        askButton.disabled = true;
        askButton.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';

        try {
            // æ·»åŠ ç”¨æˆ·æ¶ˆæ¯åˆ°ç•Œé¢
            addChatMessage('user', question);
            
            // æ›´æ–°å¯¹è¯çŠ¶æ€
            chatState.messages.push({ role: 'user', content: question });
            
            // å‘é€åˆ°åç«¯
            const response = await fetch('/api/chat', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    message: question,
                    chat_history: chatState.messages,
                    conversation_id: currentConversationId
                })
            });

            if (!response.ok) {
                throw new Error('å¯¹è¯è¯·æ±‚å¤±è´¥');
            }

            const result = await response.json();
            
            // æ·»åŠ AIå›å¤åˆ°ç•Œé¢
            addChatMessage('assistant', result.message);
            
            // æ›´æ–°å¯¹è¯çŠ¶æ€
            chatState.messages.push({ role: 'assistant', content: result.message });
            
            // å¦‚æœå¯¹è¯å®Œæˆï¼Œè¿›å…¥æ£€ç´¢é˜¶æ®µ
            if (result.status === 'complete') {
                // æ¸…ç©ºåˆ†æç»“æœåŒº
                resultPlaceholder.style.display = 'block';
                resultContent.style.display = 'none';
                const answerSection = document.querySelector('.answer-section');
                if (answerSection) answerSection.innerHTML = '';
                const sourcesList = document.querySelector('.sources-list');
                if (sourcesList) sourcesList.innerHTML = '';
                document.querySelectorAll('.conflict-warning').forEach(el => el.remove());

                // ç»§ç»­å¤„ç†æ£€ç´¢å’Œç”Ÿæˆ
                const finalResult = await processQuestion(question);
                displayResult(finalResult);
            }
            
            // é‡ç½®è¾“å…¥æ¡†çŠ¶æ€
            questionInput.value = '';
            questionInput.disabled = false;
            questionInput.focus();
            askButton.disabled = false;
            askButton.innerHTML = '<i class="fas fa-paper-plane"></i>';
            
        } catch (error) {
            console.error('å¯¹è¯å¤±è´¥:', error);
            const errorMessage = 'æŠ±æ­‰ï¼Œå¯¹è¯å‡ºç°é”™è¯¯ï¼Œè¯·é‡è¯•';
            addChatMessage('system', errorMessage);
            questionInput.disabled = false;
            askButton.disabled = false;
            askButton.innerHTML = '<i class="fas fa-paper-plane"></i>';
        }
    });

    // ä¿®æ”¹åˆ‡æ¢å¯¹è¯çš„å‡½æ•°
    async function switchConversation(convId) {
        currentConversationId = convId;
        
        // ä»æ•°æ®åº“è·å–å¯¹è¯æ¶ˆæ¯
        try {
            const response = await fetch(`/api/conversations/${convId}/messages`);
            if (!response.ok) {
                throw new Error('è·å–å¯¹è¯æ¶ˆæ¯å¤±è´¥');
            }
            const messages = await response.json();
            
            // æ›´æ–°å¯¹è¯çŠ¶æ€
            chatState.messages = messages;
            chatState.isActive = true;
            
            // æ›´æ–°ä¸»ç•Œé¢çš„å¯¹è¯
            const chatMessages = document.getElementById('chat-messages');
            chatMessages.innerHTML = '';
            messages.forEach(msg => {
                addChatMessage(msg.role, msg.content);
            });
            
            // æ›´æ–°UI
            renderConversations();
        } catch (error) {
            console.error('åˆ‡æ¢å¯¹è¯å¤±è´¥:', error);
        }
    }

    // ä¿®æ”¹è¾“å…¥æ¡†çš„å›è½¦äº‹ä»¶
    questionInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            askButton.click();
        }
    });

    // çŸ¥è¯†åº“ç®¡ç†ç›¸å…³åŠŸèƒ½
    let selectedKbFiles = new Set();
    let kbEditMode = false;

    function setKbEditMode(on) {
        kbEditMode = on;
        document.getElementById('kb-edit-controls').style.display = on ? 'flex' : 'none';
        document.getElementById('kb-normal-controls').style.display = on ? 'none' : 'block';
        renderKnowledgeBase();
    }

    async function renderKnowledgeBase() {
        const knowledgeSection = document.getElementById('knowledge-section');
        // æ¸…ç©ºç°æœ‰å†…å®¹
        knowledgeSection.innerHTML = '';
        
        try {
            const response = await fetch('/api/knowledge/files');
            if (!response.ok) throw new Error('è·å–æ–‡ä»¶åˆ—è¡¨å¤±è´¥');
            
            const files = await response.json();
            if (!files.length) {
                knowledgeSection.innerHTML = '<div style="color:#718096;text-align:center;padding:20px;">æš‚æ— æ–‡ä»¶</div>';
                return;
            }

            // ç¡®ä¿filesæ˜¯æ•°ç»„
            if (!Array.isArray(files)) {
                console.error('è¿”å›çš„æ–‡ä»¶åˆ—è¡¨ä¸æ˜¯æ•°ç»„:', files);
                return;
            }

            // ä½¿ç”¨Setæ¥å»é‡
            const uniqueFiles = Array.from(new Set(files.map(file => file.name)))
                .map(name => files.find(file => file.name === name));

            // è¿‡æ»¤æ‰.embedding.npzæ–‡ä»¶
            const filteredFiles = uniqueFiles.filter(file => {
                // ç¡®ä¿fileæ˜¯å¯¹è±¡ä¸”æœ‰nameå±æ€§
                if (!file || typeof file !== 'object' || !file.name) {
                    console.error('æ— æ•ˆçš„æ–‡ä»¶å¯¹è±¡:', file);
                    return false;
                }
                return !file.name.endsWith('.embedding.npz');
            });

            if (filteredFiles.length === 0) {
                knowledgeSection.innerHTML = '<div style="color:#718096;text-align:center;padding:20px;">æš‚æ— æ–‡ä»¶</div>';
                return;
            }

            // ä¸€æ¬¡æ€§æ„å»ºæ‰€æœ‰æ–‡ä»¶çš„HTML
            const filesHtml = filteredFiles.map(file => {
                const fileId = 'kb-file-' + file.name.replace(/[^a-zA-Z0-9]/g, '_');
                const fileSize = (file.size / 1024).toFixed(1) + ' KB';
                const isSelected = selectedKbFiles.has(file.name);
                
                return `
                    <div class="kb-file-item" data-filename="${file.name}" style="margin-bottom:8px;">
                        <div class="kb-file-header" style="cursor:pointer;background:#22344a;padding:10px;border-radius:6px;display:flex;align-items:center;gap:10px;">
                            ${kbEditMode ? `
                                <input type="checkbox" class="kb-file-checkbox" data-filename="${file.name}" 
                                    style="margin:0;" ${isSelected ? 'checked' : ''}>
                            ` : ''}
                            <i class="fas fa-file-${file.type === 'pdf' ? 'pdf' : 
                                file.type === 'txt' ? 'text' : 
                                file.type === 'md' ? 'markdown' : 
                                file.type === 'doc' || file.type === 'docx' ? 'word' : 
                                file.type === 'json' ? 'code' : 'alt'}" 
                                style="color:#38bdf8;"></i>
                            <span style="flex:1;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;">
                                ${file.name}
                            </span>
                            <span style="color:#718096;font-size:0.9em;">${fileSize}</span>
                        </div>
                    </div>
                `;
            }).join('');

            // ä¸€æ¬¡æ€§æ’å…¥æ‰€æœ‰æ–‡ä»¶çš„HTML
            knowledgeSection.innerHTML = filesHtml;

            // ç»‘å®šå¤é€‰æ¡†äº‹ä»¶
            if (kbEditMode) {
                document.querySelectorAll('.kb-file-checkbox').forEach(cb => {
                    cb.onchange = function() {
                        const filename = this.getAttribute('data-filename');
                        if (this.checked) {
                            selectedKbFiles.add(filename);
                        } else {
                            selectedKbFiles.delete(filename);
                        }
                    };
                });
            }
        } catch (error) {
            console.error('æ¸²æŸ“çŸ¥è¯†åº“æ–‡ä»¶åˆ—è¡¨å¤±è´¥:', error);
            knowledgeSection.innerHTML = '<div style="color:#f87171;text-align:center;padding:20px;">åŠ è½½å¤±è´¥</div>';
        }
    }

    // æ–‡ä»¶ä¸Šä¼ å¤„ç†
    document.getElementById('file-upload').addEventListener('change', async function(e) {
        const files = e.target.files;
        if (!files.length) return;

        const formData = new FormData();
        for (let file of files) {
            formData.append('files[]', file, file.name);
        }

        try {
            const response = await fetch('/api/knowledge/upload', {
                method: 'POST',
                body: formData
            });

            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.error || 'ä¸Šä¼ å¤±è´¥');
            }
            
            const result = await response.json();
            if (result.error) throw new Error(result.error);
            
            alert('æ–‡ä»¶ä¸Šä¼ æˆåŠŸ');
            await renderKnowledgeBase();
        } catch (error) {
            console.error('æ–‡ä»¶ä¸Šä¼ å¤±è´¥:', error);
            alert('æ–‡ä»¶ä¸Šä¼ å¤±è´¥: ' + error.message);
        }

        // æ¸…ç©ºæ–‡ä»¶è¾“å…¥
        e.target.value = '';
    });

    // åˆ·æ–°æŒ‰é’®
    document.getElementById('refresh-kb-btn').onclick = renderKnowledgeBase;

    // ç¼–è¾‘æŒ‰é’®ç‚¹å‡»äº‹ä»¶
    document.getElementById('edit-kb-btn').onclick = () => {
        setKbEditMode(true);
    };

    // å–æ¶ˆç¼–è¾‘æŒ‰é’®ç‚¹å‡»äº‹ä»¶
    document.getElementById('cancel-kb-edit-btn').onclick = () => {
        setKbEditMode(false);
        selectedKbFiles.clear();
    };

    // å…¨é€‰æŒ‰é’®ç‚¹å‡»äº‹ä»¶
    document.getElementById('select-all-kb-btn').onclick = function() {
        const checkboxes = document.querySelectorAll('.kb-file-checkbox');
        const allChecked = Array.from(checkboxes).every(cb => cb.checked);
        
        checkboxes.forEach(cb => {
            const filename = cb.getAttribute('data-filename');
            cb.checked = !allChecked;
            if (!allChecked) {
                selectedKbFiles.add(filename);
            } else {
                selectedKbFiles.delete(filename);
            }
        });
    };

    // åˆ é™¤é€‰ä¸­æŒ‰é’®ç‚¹å‡»äº‹ä»¶
    document.getElementById('delete-selected-kb-btn').onclick = async function() {
        if (!selectedKbFiles.size) {
            alert('è¯·å…ˆé€‰æ‹©è¦åˆ é™¤çš„æ–‡ä»¶');
            return;
        }

        if (!confirm('ç¡®å®šè¦åˆ é™¤é€‰ä¸­çš„æ–‡ä»¶å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ¢å¤ã€‚')) return;

        try {
            const response = await fetch('/api/knowledge/delete', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    filenames: Array.from(selectedKbFiles)
                })
            });

            const result = await response.json();
            
            if (!response.ok) {
                console.error('åˆ é™¤æ–‡ä»¶å¤±è´¥:', result.error);
            } else {
                alert('æ–‡ä»¶åˆ é™¤æˆåŠŸ');
                await renderKnowledgeBase();
            }
        } catch (error) {
            console.error('åˆ é™¤æ–‡ä»¶å¤±è´¥:', error);
            alert('åˆ é™¤æ–‡ä»¶å¤±è´¥: ' + error.message);
        }
    };

    // åŠ è½½å†å²å¯¹è¯
    async function loadConversation(conversationId) {
        try {
            const response = await fetch(`/api/conversations/${conversationId}`);
            const data = await response.json();
            // å¤„ç†å¯¹è¯æ•°æ®
            displayConversation(data);
        } catch (error) {
            console.error('åŠ è½½å¯¹è¯å¤±è´¥:', error);
        }
    }

    // æ˜¾ç¤ºå¯¹è¯å†…å®¹
    function displayConversation(data) {
        const chatContainer = document.getElementById('chat-container');
        if (!chatContainer) return;

        chatContainer.innerHTML = '';
        
        data.messages.forEach(message => {
            const messageElement = document.createElement('div');
            messageElement.className = `message ${message.role}`;
            messageElement.innerHTML = `
                <div class="message-content">
                    <div class="message-text">${message.content}</div>
                </div>
            `;
            chatContainer.appendChild(messageElement);
        });
        
        // æ»šåŠ¨åˆ°åº•éƒ¨
        chatContainer.scrollTop = chatContainer.scrollHeight;
    }

    // åˆå§‹åŒ–çŸ¥è¯†åº“
    function initKnowledgeBase() {
        const uploadBtn = document.getElementById('upload-btn');
        if (uploadBtn) {
            uploadBtn.addEventListener('click', () => {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.pdf,.txt,.doc,.docx';
                input.onchange = handleFileUpload;
                input.click();
            });
        }
    }

    // å¤„ç†æ–‡ä»¶ä¸Šä¼ 
    async function handleFileUpload(event) {
        const file = event.target.files[0];
        if (!file) return;

        const formData = new FormData();
        formData.append('file', file);

        try {
            const response = await fetch('/api/upload', {
                method: 'POST',
                body: formData
            });
            
            if (response.ok) {
                // åˆ·æ–°çŸ¥è¯†åº“åˆ—è¡¨
                refreshKnowledgeBase();
            } else {
                console.error('æ–‡ä»¶ä¸Šä¼ å¤±è´¥');
            }
        } catch (error) {
            console.error('ä¸Šä¼ å‡ºé”™:', error);
        }
    }

    // åˆ·æ–°çŸ¥è¯†åº“åˆ—è¡¨
    async function refreshKnowledgeBase() {
        try {
            const response = await fetch('/api/knowledge');
            const data = await response.json();
            renderKnowledgeBase(data);
        } catch (error) {
            console.error('è·å–çŸ¥è¯†åº“å¤±è´¥:', error);
        }
    }

    // æ¸²æŸ“çŸ¥è¯†åº“
    function renderKnowledgeBase(data) {
        const container = document.getElementById('knowledge-files');
        if (!container) return;

        container.innerHTML = '';
        
        if (!data || data.length === 0) {
            container.innerHTML = '<div class="empty-message">æš‚æ— çŸ¥è¯†åº“æ–‡ä»¶</div>';
            return;
        }

        data.forEach(file => {
            const fileElement = document.createElement('div');
            fileElement.className = 'knowledge-file';
            fileElement.innerHTML = `
                <div class="knowledge-file-info">
                    <div class="knowledge-file-name">${file.name}</div>
                    <div class="knowledge-file-size">${formatFileSize(file.size)}</div>
                </div>
                <div class="knowledge-file-actions">
                    <button onclick="deleteFile('${file.id}')" title="åˆ é™¤">
                        <i class="fas fa-trash"></i>
                    </button>
                </div>
            `;
            container.appendChild(fileElement);
        });
    }

    // åˆ é™¤æ–‡ä»¶
    async function deleteFile(fileId) {
        if (!confirm('ç¡®å®šè¦åˆ é™¤è¿™ä¸ªæ–‡ä»¶å—ï¼Ÿ')) return;

        try {
            const response = await fetch(`/api/knowledge/${fileId}`, {
                method: 'DELETE'
            });
            
            if (response.ok) {
                refreshKnowledgeBase();
            } else {
                console.error('åˆ é™¤æ–‡ä»¶å¤±è´¥');
            }
        } catch (error) {
            console.error('åˆ é™¤å‡ºé”™:', error);
        }
    }

    // æ ¼å¼åŒ–æ–‡ä»¶å¤§å°
    function formatFileSize(bytes) {
        if (bytes === 0) return '0 B';
        const k = 1024;
        const sizes = ['B', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }

    // è¾…åŠ©å‡½æ•°
    function cleanWebPageNoise(md) {
        if (!md) return '';
        // 1. ç§»é™¤æ‰€æœ‰å•ç‹¬ä¸€è¡Œçš„æ ‡é¢˜ï¼ˆ#ã€##ã€###ç­‰ï¼‰
        md = md.replace(/^#{1,6} .+$/gm, '');
        // 2. ç§»é™¤å¸¸è§æ ç›®/å¯¼èˆª/å¹¿å‘Šç­‰çŸ­è¡Œ
        const navWords = [
            'é¦–é¡µ', 'ä¸“é¢˜', 'ç™¾ç§‘', 'å†ç°å†å²', 'ç”Ÿæ´»', 'è¯´å‰§', 'è‹±æ–‡ç‰ˆ', 'å†å²è¯é¢˜', 'MILITARY TOPIC', 'æ¢å¯»å†å²é£äº‘æ—§äº‹',
            'äººç‰©', 'å½±è§†', 'è§£æ¢¦', 'ç™¾å®¶å§“', 'æˆè¯­', 'æ˜æ˜Ÿ', 'å†å²', 'æ•™è‚²', 'ä¸‰å›½', 'æ–°é—»', 'æ‰‹æœºç‰ˆ'
        ];
        navWords.forEach(word => {
            // ç§»é™¤å•ç‹¬ä¸€è¡Œçš„æ ç›®è¯
            md = md.replace(new RegExp('^' + word + '\\s*$', 'gm'), '');
        });
        // 3. ç§»é™¤å…¨å¤§å†™çš„çŸ­è¡Œ
        md = md.replace(/^[A-Z\\s]{3,30}$/gm, '');
        // 4. ç§»é™¤"|"åˆ†éš”çš„å¯¼èˆªè¡Œ
        md = md.replace(/^[\\w\\u4e00-\\u9fa5\\s\\|]{5,40}$/gm, function(line) {
            // åªä¿ç•™å«æœ‰"|"ä¸”å…¨ä¸ºæ ç›®è¯çš„è¡Œ
            if (line.includes('|')) return '';
            return line;
        });
        // 5. ç§»é™¤å¤šä½™ç©ºè¡Œ
        md = md.replace(/\\n{2,}/g, '\\n\\n');
        // 6. ç§»é™¤å¼€å¤´å’Œç»“å°¾çš„ç©ºç™½
        md = md.trim();
        return md;
    }

    function cleanMarkdownHeadings(md) {
        return md.replace(/^#{1,2} (.*)$/gm, '### $1');
    }

    function truncateMarkdownContent(md, maxLen = 400) {
        if (!md) return '';
        if (md.length <= maxLen) return marked.parse(md);
        const short = md.slice(0, maxLen);
        const id = 'expand-' + Math.random().toString(36).slice(2, 10);
        return `
            <div>
                <div id="${id}-short">${marked.parse(short)}<span style="color:#38bdf8;cursor:pointer;" onclick="document.getElementById('${id}-short').style.display='none';document.getElementById('${id}-full').style.display='block';">[å±•å¼€]</span></div>
                <div id="${id}-full" style="display:none;">${marked.parse(md)}<span style="color:#38bdf8;cursor:pointer;" onclick="document.getElementById('${id}-full').style.display='none';document.getElementById('${id}-short').style.display='block';">[æ”¶èµ·]</span></div>
            </div>
        `;
    }

    // å…¨å±€å˜é‡
    let progressMessages = [null, '', '', '', ''];
    let maxStepReached = 0;
    let currentStep = 0;
    let finalAnswer = '';
    let lastQuestion = '';
    let lastAnswer = '';
    let lastCreatedAt = '';
    let editMode = false;
    let selectedIds = [];

    // ä¸»è¦åŠŸèƒ½å‡½æ•°
    function updateProgress(step, message) {
        currentStep = step;
        if (step > maxStepReached) maxStepReached = step;
        const progressBar = document.getElementById('progress-bar');
        progressBar.style.width = `${step * 25}%`;

        const steps = document.querySelectorAll('.step');
        steps.forEach((s, i) => {
            if (i < step - 1) {
                s.classList.add('completed');
                s.classList.remove('active');
            } else if (i === step - 1) {
                s.classList.add('active');
                s.classList.remove('completed');
            } else {
                s.classList.remove('active', 'completed');
            }
        });

        const contents = document.querySelectorAll('.progress-content');
        contents.forEach((c, idx) => {
            c.classList.remove('active');
            if (idx === step - 1) {
                c.classList.add('active');
                c.querySelector('.content-body').innerHTML = message;
            } else if (progressMessages[idx + 1]) {
                c.querySelector('.content-body').innerHTML = progressMessages[idx + 1];
            }
        });
    }

    function showStepContent(stepNumber) {
        const steps = document.querySelectorAll('.step');
        const contents = document.querySelectorAll('.progress-content');
        const progressBar = document.getElementById('progress-bar');

        steps.forEach((step, index) => {
            if (index === stepNumber - 1) {
                step.classList.add('active');
            } else {
                step.classList.remove('active');
            }
            if (index < stepNumber - 1) {
                step.classList.add('completed');
            } else {
                step.classList.remove('completed');
            }
        });

        contents.forEach((content, idx) => {
            content.classList.remove('active');
            if (idx === stepNumber - 1) {
                content.classList.add('active');
            }
        });

        progressBar.style.width = `${stepNumber * 25}%`;
    }

    async function processQuestion(question) {
        try {
            // Step 1: é—®é¢˜æ¥æ”¶
            progressMessages[1] = `å·²æ¥æ”¶åˆ°æ‚¨çš„é—®é¢˜ï¼š<br><b>${question}</b><br>æ­£åœ¨å¼€å§‹å¤„ç†...`;
            updateProgress(1, progressMessages[1]);
            maxStepReached = 1;

            // Step 2: æ–‡æ¡£æ£€ç´¢
            const customUrl = document.getElementById('custom-url-input').value.trim();
            const searchMode = document.getElementById('search-mode').value;
            const enableWebSearch = document.getElementById('enable-web-search');
            const maxIterations = document.getElementById('max-iterations');

            const retrievalResponse = await fetch('/api/retrieve', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    question,
                    enable_web_search: enableWebSearch.checked,
                    max_iterations: parseInt(maxIterations.value),
                    custom_url: customUrl,
                    search_mode: searchMode
                })
            });

            if (!retrievalResponse.ok) throw new Error('æ£€ç´¢å¤±è´¥');
            const contexts = await retrievalResponse.json();
            let retrievalContent = "æ£€ç´¢åˆ°çš„ç›¸å…³å†…å®¹ï¼š<br><br>";
            
            contexts.forEach((ctx, idx) => {
                let typeLabel = '';
                if (ctx.type === 'æŒ‡å®šç½‘é¡µ') {
                    typeLabel = `<span style="color:#38bdf8;font-weight:bold;">ã€æŒ‡å®šç½‘é¡µã€‘</span> `;
                } else if (ctx.type === 'ç½‘ç»œæ¥æº') {
                    typeLabel = `<span style="color:#4ade80;">ã€è”ç½‘æ£€ç´¢ã€‘</span> `;
                } else {
                    typeLabel = `<span style="color:#fbbf24;">ã€æœ¬åœ°æ–‡æ¡£ã€‘</span> `;
                }

                let title = ctx.title ? `<b>${ctx.title}</b> ` : '';
                let url = (ctx.type === 'æŒ‡å®šç½‘é¡µ' || ctx.type === 'ç½‘ç»œæ¥æº') && ctx.url
                    ? `<a href="${ctx.url}" target="_blank" style="color:#38bdf8;text-decoration:underline;">${ctx.url}</a><br>`
                    : '';

                let contentHtml;
                if (ctx.type === 'æŒ‡å®šç½‘é¡µ') {
                    let cleaned = cleanWebPageNoise(ctx.content || '');
                    cleaned = cleanMarkdownHeadings(cleaned);
                    contentHtml = truncateMarkdownContent(cleaned, 400);
                } else {
                    contentHtml = marked.parse(ctx.content ? ctx.content.substring(0, 200) : '');
                }

                retrievalContent += `${idx + 1}. ${typeLabel}${title}${url}${contentHtml}<br><br>`;
            });

            progressMessages[2] = retrievalContent;
            updateProgress(2, progressMessages[2]);
            maxStepReached = 2;

            await new Promise(resolve => setTimeout(resolve, 2000));

            // Step 3: ç”Ÿæˆç­”æ¡ˆï¼ˆæµå¼è¾“å‡ºï¼‰
            progressMessages[3] = `<b>ç”Ÿæˆçš„ç­”æ¡ˆï¼š</b><br><span id='streaming-answer'></span>`;
            updateProgress(3, progressMessages[3]);
            maxStepReached = 3;

            const response = await fetch('/api/generate_stream', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ question, contexts })
            });

            const reader = response.body.getReader();
            let decoder = new TextDecoder();
            let resultText = '';
            let streamingAnswer = document.getElementById('streaming-answer');
            const answerSection = document.querySelector('.answer-section');

            while (true) {
                const { done, value } = await reader.read();
                if (done) break;
                const chunk = decoder.decode(value, { stream: true });
                resultText += chunk;
                if (streamingAnswer) streamingAnswer.innerHTML = marked.parse(resultText);
                if (answerSection) answerSection.innerHTML = marked.parse(resultText);
            }

            finalAnswer = resultText;
            progressMessages[3] = `<b>ç”Ÿæˆçš„ç­”æ¡ˆï¼š</b><br>${marked.parse(finalAnswer)}`;
            updateProgress(3, progressMessages[3]);
            if (answerSection) answerSection.innerHTML = marked.parse(finalAnswer);

            // Step 4: å†²çªæ£€æµ‹
            progressMessages[4] = `<b>å†²çªæ£€æµ‹æ€»ç»“ï¼š</b><br><span id='streaming-conflict'>æ­£åœ¨ç­‰å¾…å†²çªæ£€æµ‹ç»“æœ...<span class='loading-dots'></span></span>`;
            updateProgress(4, progressMessages[4]);
            maxStepReached = 4;

            const conflictResponse = await fetch('/api/conflict_stream', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ contexts })
            });

            const conflictReader = conflictResponse.body.getReader();
            let conflictDecoder = new TextDecoder();
            let conflictText = '';
            let streamingConflict = document.getElementById('streaming-conflict');
            let firstChunk = true;

            try {
                while (true) {
                    const { done, value } = await conflictReader.read();
                    if (done) break;
                    const chunk = conflictDecoder.decode(value, { stream: true });
                    conflictText += chunk;
                    if (streamingConflict) {
                        if (firstChunk) {
                            streamingConflict.innerHTML = '';
                            firstChunk = false;
                        }
                        streamingConflict.innerHTML = marked.parse(conflictText);
                    }
                }
            } catch (e) {
                console.error('å†²çªæ£€æµ‹æµå¼è¾“å‡ºé”™è¯¯:', e);
                if (streamingConflict) {
                    streamingConflict.innerHTML = '<span style="color:#fbbf24;">âš ï¸ å†²çªæ£€æµ‹è¿‡ç¨‹ä¸­å‡ºç°é”™è¯¯ï¼Œä½†ä¸ä¼šå½±å“æœ€ç»ˆç­”æ¡ˆçš„ç”Ÿæˆã€‚</span>';
                }
                conflictText = 'å†²çªæ£€æµ‹è¿‡ç¨‹ä¸­å‡ºç°é”™è¯¯ï¼Œä½†ä¸ä¼šå½±å“æœ€ç»ˆç­”æ¡ˆçš„ç”Ÿæˆã€‚';
            }

            if (streamingConflict && (!conflictText || conflictText.trim() === '')) {
                streamingConflict.innerHTML = '<span style="color:#38bdf8;">æœªæ£€æµ‹åˆ°æ˜æ˜¾å†²çªã€‚</span>';
                conflictText = 'æœªæ£€æµ‹åˆ°æ˜æ˜¾å†²çªã€‚';
            }

            const result = {
                answer: finalAnswer,
                sources: contexts,
                hasConflicts: /æœ‰å†²çª/.test(conflictText),
                conflict_reason: conflictText,
                injected_prompt: ''
            };

            if (!result || !Array.isArray(result.sources)) {
                result.sources = [];
            } else if (Array.isArray(result.sources[0])) {
                result.sources = result.sources.flat();
            }
            result.sources = result.sources.filter(item => item && typeof item === 'object');
            return result;
        } catch (error) {
            throw error;
        }
    }

    function displayResult(result) {
        try {
            console.log('displayResultæ”¶åˆ°çš„result:', result);
            if (!result || !Array.isArray(result.sources)) {
                result.sources = [];
            } else if (Array.isArray(result.sources[0])) {
                result.sources = result.sources.flat();
            }
            result.sources = result.sources.filter(item => item && typeof item === 'object');

            const resultPlaceholder = document.getElementById('result-placeholder');
            const resultContent = document.getElementById('result-content');
            resultPlaceholder.style.display = 'none';
            resultContent.style.display = 'block';

            // æŠ˜å ä¸Šä¸€æ¬¡ç»“æœåˆ°å†å²åŒº
            if (lastQuestion && lastAnswer) {
                const historySection = document.getElementById('history-section');
                const historyId = 'history-local-' + Date.now();
                let createdAt = '';
                if (lastCreatedAt) {
                    const dateObj = new Date(lastCreatedAt.replace(' ', 'T').replace(/-/g, '/'));
                    createdAt = dateObj.toLocaleString('zh-CN', { hour12: false });
                    if (createdAt.startsWith('æ—¶é—´ï¼š')) {
                        createdAt = createdAt.replace(/^æ—¶é—´ï¼š/, '');
                    }
                }

                const html = `
                    <div class="history-item" style="margin-bottom:8px;">
                        <div class="history-header" style="cursor:pointer;background:#22344a;padding:10px;border-radius:6px;" onclick="const b=document.getElementById('${historyId}-body');b.style.display=b.style.display==='none'?'block':'none'">
                            <b>å†å²æé—®ï¼š</b> ${lastQuestion.replace(/</g,'&lt;').replace(/>/g,'&gt;').slice(0,60)} <span style="color:#38bdf8;">[ç‚¹å‡»å±•å¼€/æ”¶èµ·]</span>
                        </div>
                        <div class="history-body" id="${historyId}-body" style="display:none;background:#1a2533;padding:12px;border-radius:6px;">
                            <b>é—®é¢˜ï¼š</b> ${lastQuestion.replace(/</g,'&lt;').replace(/>/g,'&gt;')}<br><b>ç­”æ¡ˆï¼š</b><br>${marked.parse(lastAnswer||'')}
                            <div style="color:#888;font-size:0.92em;margin-top:6px;">${createdAt ? 'æ—¶é—´ï¼š' + createdAt : ''}</div>
                        </div>
                    </div>
                `;
                historySection.insertAdjacentHTML('afterbegin', html);
            }

            // è®°å½•æœ¬æ¬¡é—®é¢˜å’Œç­”æ¡ˆ
            lastQuestion = '';
            lastAnswer = '';
            if (
                result.sources &&
                result.sources.length &&
                typeof result.sources[0] === 'object' &&
                result.sources[0] !== null &&
                'question' in result.sources[0]
            ) {
                lastQuestion = result.sources[0].question;
            } else if (window.currentQuestion) {
                lastQuestion = window.currentQuestion;
            }
            lastAnswer = result.answer || '';
            lastCreatedAt = result.created_at;

            // Display answer
            const answerSection = resultContent.querySelector('.answer-section');
            answerSection.innerHTML = marked.parse(result.answer || '');

            // Display sources
            const sourcesList = resultContent.querySelector('.sources-list');
            sourcesList.innerHTML = '';
            (result.sources || []).forEach(source => {
                const sourceElement = document.createElement('div');
                sourceElement.className = 'source-item';

                let typeLabel = '';
                let icon = '';
                let urlHtml = '';
                let title = source.title ? `<b>${source.title}</b><br>` : '';

                if (source.type === 'æŒ‡å®šç½‘é¡µ') {
                    typeLabel = `<span style="color:#38bdf8;font-weight:bold;">ğŸŒ æŒ‡å®šç½‘é¡µ</span>`;
                    icon = 'ğŸŒ';
                    if (source.url) {
                        urlHtml = `<div style="margin-top:4px;"><a href="${source.url}" target="_blank" style="color:#38bdf8;text-decoration:underline;">${source.url}</a></div>`;
                    }
                } else if (source.type === 'ç½‘ç»œæ¥æº') {
                    typeLabel = `<span style="color:#4ade80;">ğŸŒ è”ç½‘æ£€ç´¢</span>`;
                    icon = 'ğŸŒ';
                    if (source.url) {
                        urlHtml = `<div style="margin-top:4px;"><a href="${source.url}" target="_blank" style="color:#38bdf8;text-decoration:underline;">${source.url}</a></div>`;
                    }
                } else {
                    typeLabel = `<span style="color:#fbbf24;">ğŸ“„ æœ¬åœ°æ–‡æ¡£</span>`;
                    icon = 'ğŸ“„';
                }

                let contentHtml;
                if (source.type === 'æŒ‡å®šç½‘é¡µ') {
                    let cleaned = cleanWebPageNoise(source.content || '');
                    cleaned = cleanMarkdownHeadings(cleaned);
                    contentHtml = truncateMarkdownContent(cleaned, 400);
                } else {
                    contentHtml = marked.parse(source.content || '');
                }

                sourceElement.innerHTML = `
                    <div class="source-type">${typeLabel}</div>
                    <div class="source-content">
                        ${title}
                        ${contentHtml}
                        ${urlHtml}
                    </div>
                `;
                sourcesList.appendChild(sourceElement);
            });

            // Display conflict warning if needed
            if (result.hasConflicts) {
                const warningElement = document.createElement('div');
                warningElement.className = 'conflict-warning';
                warningElement.innerHTML = `
                    <i class="fas fa-exclamation-triangle"></i>
                    <p>æ£€æµ‹åˆ°ä¸åŒæ¥æºçš„ä¿¡æ¯å­˜åœ¨æ½œåœ¨å†²çªï¼Œè¯·æ³¨æ„ç”„åˆ«ã€‚</p>
                    <div style='margin-top:8px; color:#fbbf24; font-size:0.98rem;'><b>å†²çªæ£€æµ‹æ¨ç†è¿‡ç¨‹ï¼š</b><br>${marked.parse(result.conflict_reason || '')}</div>
                `;
                resultContent.appendChild(warningElement);
            }
        } catch (e) {
            console.error('åˆ†æç»“æœæ¸²æŸ“å¼‚å¸¸:', e, result);
            alert('åˆ†æç»“æœæ¸²æŸ“å¼‚å¸¸ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•\n' + e.message);
        }
    }

    // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
    document.addEventListener('DOMContentLoaded', async () => {
        try {
            console.log('é¡µé¢å¼€å§‹åŠ è½½...');
            
            // åˆå§‹åŒ–å¯¹è¯çŠ¶æ€
            chatState = {
                messages: [],
                isActive: false
            };
            
            // åŠ è½½å†å²å¯¹è¯è®°å½•
            console.log('å¼€å§‹è·å–å¯¹è¯åˆ—è¡¨...');
            const response = await fetch('/api/conversations');
            console.log('è·å–åˆ°å“åº”:', response.status);
            
            if (!response.ok) {
                throw new Error('è·å–å¯¹è¯åˆ—è¡¨å¤±è´¥');
            }
            
            const conversations = await response.json();
            console.log('è·å–åˆ°å¯¹è¯åˆ—è¡¨:', conversations);
            
            // å¦‚æœæ²¡æœ‰å¯¹è¯è®°å½•ï¼Œåˆ›å»ºä¸€ä¸ªæµ‹è¯•å¯¹è¯
            if (conversations.length === 0) {
                console.log('æ²¡æœ‰å¯¹è¯è®°å½•ï¼Œåˆ›å»ºæµ‹è¯•å¯¹è¯...');
                const testResponse = await fetch('/api/conversations', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        id: 'test-' + Date.now(),
                        title: 'æµ‹è¯•å¯¹è¯'
                    })
                });
                
                if (testResponse.ok) {
                    console.log('æµ‹è¯•å¯¹è¯åˆ›å»ºæˆåŠŸ');
                    // é‡æ–°åŠ è½½å¯¹è¯åˆ—è¡¨
                    const newResponse = await fetch('/api/conversations');
                    if (newResponse.ok) {
                        const newConversations = await newResponse.json();
                        conversations.push(...newConversations);
                    }
                }
            }
            
            // æ›´æ–°å¯¹è¯åˆ—è¡¨
            const conversationList = document.getElementById('conversation-list');
            if (!conversationList) {
                console.error('æ‰¾ä¸åˆ°å¯¹è¯åˆ—è¡¨å…ƒç´ ');
                return;
            }
            
            conversationList.innerHTML = '';
            
            if (conversations.length === 0) {
                console.log('æ²¡æœ‰æ‰¾åˆ°ä»»ä½•å¯¹è¯è®°å½•');
                const emptyMessage = document.createElement('div');
                emptyMessage.className = 'empty-message';
                emptyMessage.textContent = 'æš‚æ— å¯¹è¯è®°å½•';
                conversationList.appendChild(emptyMessage);
            } else {
                conversations.forEach(conv => {
                    console.log('å¤„ç†å¯¹è¯:', conv);
                    const conversationItem = document.createElement('div');
                    conversationItem.className = 'conversation-item';
                    conversationItem.dataset.id = conv.id;
                    
                    const title = document.createElement('div');
                    title.className = 'conversation-title';
                    title.textContent = conv.title || 'æ–°å¯¹è¯';
                    
                    const time = document.createElement('div');
                    time.className = 'conversation-time';
                    time.textContent = new Date(conv.created_at).toLocaleString();
                    
                    conversationItem.appendChild(title);
                    conversationItem.appendChild(time);
                    
                    conversationItem.addEventListener('click', () => loadConversation(conv.id));
                    conversationList.appendChild(conversationItem);
                });
            }
            
            // åˆå§‹åŒ–äº‹ä»¶ç›‘å¬
            initializeEventListeners();
            
            // èšç„¦åˆ°è¾“å…¥æ¡†
            const questionInput = document.getElementById('question-input');
            if (questionInput) {
                questionInput.focus();
            }
            
            console.log('é¡µé¢åˆå§‹åŒ–å®Œæˆ');
        } catch (error) {
            console.error('åˆå§‹åŒ–å¤±è´¥:', error);
        }
    });

    // åˆå§‹åŒ–äº‹ä»¶ç›‘å¬å™¨
    function initializeEventListeners() {
        // æé—®æŒ‰é’®ç‚¹å‡»äº‹ä»¶
        const askButton = document.getElementById('ask-button');
        const questionInput = document.getElementById('question-input');
        
        if (askButton && questionInput) {
            askButton.addEventListener('click', async () => {
                const question = questionInput.value.trim();
                if (!question) return;

                // å¦‚æœæ²¡æœ‰å½“å‰å¯¹è¯ï¼Œåˆ›å»ºæ–°å¯¹è¯
                if (!currentConversationId) {
                    currentConversationId = 'conv-' + Date.now();
                    const newConversation = {
                        id: currentConversationId,
                        title: question.slice(0, 30) + (question.length > 30 ? '...' : ''),
                        created_at: new Date().toISOString()
                    };
                    
                    try {
                        const response = await fetch('/api/conversations', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(newConversation)
                        });
                        
                        if (!response.ok) {
                            throw new Error('åˆ›å»ºå¯¹è¯å¤±è´¥');
                        }
                        
                        await loadConversations();
                    } catch (error) {
                        console.error('ä¿å­˜å¯¹è¯å¤±è´¥:', error);
                        return;
                    }
                }

                // ç¦ç”¨è¾“å…¥å’ŒæŒ‰é’®
                questionInput.disabled = true;
                askButton.disabled = true;
                askButton.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';

                try {
                    // æ·»åŠ ç”¨æˆ·æ¶ˆæ¯åˆ°ç•Œé¢
                    addChatMessage('user', question);
                    
                    // æ›´æ–°å¯¹è¯çŠ¶æ€
                    chatState.messages.push({ role: 'user', content: question });
                    
                    // å‘é€åˆ°åç«¯
                    const response = await fetch('/api/chat', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            message: question,
                            chat_history: chatState.messages,
                            conversation_id: currentConversationId
                        })
                    });

                    if (!response.ok) {
                        throw new Error('å¯¹è¯è¯·æ±‚å¤±è´¥');
                    }

                    const result = await response.json();
                    
                    // æ·»åŠ AIå›å¤åˆ°ç•Œé¢
                    addChatMessage('assistant', result.message);
                    
                    // æ›´æ–°å¯¹è¯çŠ¶æ€
                    chatState.messages.push({ role: 'assistant', content: result.message });
                    
                    // å¦‚æœå¯¹è¯å®Œæˆï¼Œè¿›å…¥æ£€ç´¢é˜¶æ®µ
                    if (result.status === 'complete') {
                        // æ¸…ç©ºåˆ†æç»“æœåŒº
                        const resultPlaceholder = document.getElementById('result-placeholder');
                        const resultContent = document.getElementById('result-content');
                        resultPlaceholder.style.display = 'block';
                        resultContent.style.display = 'none';
                        const answerSection = document.querySelector('.answer-section');
                        if (answerSection) answerSection.innerHTML = '';
                        const sourcesList = document.querySelector('.sources-list');
                        if (sourcesList) sourcesList.innerHTML = '';
                        document.querySelectorAll('.conflict-warning').forEach(el => el.remove());

                        // ç»§ç»­å¤„ç†æ£€ç´¢å’Œç”Ÿæˆ
                        const finalResult = await processQuestion(question);
                        displayResult(finalResult);
                    }
                    
                    // é‡ç½®è¾“å…¥æ¡†çŠ¶æ€
                    questionInput.value = '';
                    questionInput.disabled = false;
                    questionInput.focus();
                    askButton.disabled = false;
                    askButton.innerHTML = '<i class="fas fa-paper-plane"></i>';
                    
                } catch (error) {
                    console.error('å¯¹è¯å¤±è´¥:', error);
                    const errorMessage = 'æŠ±æ­‰ï¼Œå¯¹è¯å‡ºç°é”™è¯¯ï¼Œè¯·é‡è¯•';
                    addChatMessage('system', errorMessage);
                    questionInput.disabled = false;
                    askButton.disabled = false;
                    askButton.innerHTML = '<i class="fas fa-paper-plane"></i>';
                }
            });

            // è¾“å…¥æ¡†å›è½¦äº‹ä»¶
            questionInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    askButton.click();
                }
            });
        }

        // æ ‡ç­¾é¡µåˆ‡æ¢
        const historyTabBtn = document.getElementById('history-tab-btn');
        const knowledgeTabBtn = document.getElementById('knowledge-tab-btn');
        const historyPanel = document.getElementById('history-panel');
        const knowledgePanel = document.getElementById('knowledge-panel');

        if (historyTabBtn && knowledgeTabBtn && historyPanel && knowledgePanel) {
            historyTabBtn.onclick = () => switchTab('history');
            knowledgeTabBtn.onclick = () => switchTab('knowledge');
        }

        // ä¾§è¾¹æ æ”¶ç¼©/å±•å¼€
        const sidebar = document.getElementById('sidebar');
        const toggleBtn = document.getElementById('toggle-sidebar-btn');
        const openSidebarBtn = document.getElementById('open-sidebar-btn');

        if (sidebar && toggleBtn && openSidebarBtn) {
            toggleBtn.onclick = function() {
                sidebarCollapsed = true;
                sidebar.style.width = '0';
                sidebar.style.minWidth = '0';
                sidebar.style.padding = '0';
                sidebar.style.overflow = 'hidden';
                sidebar.style.boxShadow = 'none';
                sidebar.style.borderRadius = '0 16px 16px 0';
                document.getElementById('main-inner').style.paddingLeft = '0';
                toggleBtn.style.display = 'none';
                openSidebarBtn.style.display = 'block';
            };

            openSidebarBtn.onclick = function() {
                sidebarCollapsed = false;
                sidebar.style.width = '320px';
                sidebar.style.minWidth = '220px';
                sidebar.style.padding = '18px 10px 18px 18px';
                sidebar.style.overflow = '';
                sidebar.style.boxShadow = 'var(--glow),2px 0 16px 0 rgba(58,134,255,0.08)';
                sidebar.style.borderRadius = '0 16px 16px 0';
                document.getElementById('main-inner').style.paddingLeft = '320px';
                toggleBtn.style.display = '';
                openSidebarBtn.style.display = 'none';
            };
        }

        // çŸ¥è¯†åº“ç›¸å…³æŒ‰é’®
        const editKbBtn = document.getElementById('edit-kb-btn');
        const cancelKbEditBtn = document.getElementById('cancel-kb-edit-btn');
        const selectAllKbBtn = document.getElementById('select-all-kb-btn');
        const deleteSelectedKbBtn = document.getElementById('delete-selected-kb-btn');
        const refreshKbBtn = document.getElementById('refresh-kb-btn');
        const fileUpload = document.getElementById('file-upload');

        if (editKbBtn) {
            editKbBtn.onclick = () => setKbEditMode(true);
        }
        if (cancelKbEditBtn) {
            cancelKbEditBtn.onclick = () => {
                setKbEditMode(false);
                selectedKbFiles.clear();
            };
        }
        if (selectAllKbBtn) {
            selectAllKbBtn.onclick = function() {
                const checkboxes = document.querySelectorAll('.kb-file-checkbox');
                const allChecked = Array.from(checkboxes).every(cb => cb.checked);
                
                checkboxes.forEach(cb => {
                    const filename = cb.getAttribute('data-filename');
                    cb.checked = !allChecked;
                    if (!allChecked) {
                        selectedKbFiles.add(filename);
                    } else {
                        selectedKbFiles.delete(filename);
                    }
                });
            };
        }
        if (deleteSelectedKbBtn) {
            deleteSelectedKbBtn.onclick = async function() {
                if (!selectedKbFiles.size) {
                    alert('è¯·å…ˆé€‰æ‹©è¦åˆ é™¤çš„æ–‡ä»¶');
                    return;
                }

                if (!confirm('ç¡®å®šè¦åˆ é™¤é€‰ä¸­çš„æ–‡ä»¶å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ¢å¤ã€‚')) return;

                try {
                    const response = await fetch('/api/knowledge/delete', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            filenames: Array.from(selectedKbFiles)
                        })
                    });

                    const result = await response.json();
                    
                    if (!response.ok) {
                        throw new Error(result.error || 'åˆ é™¤å¤±è´¥');
                    }

                    if (result.errors && result.errors.length > 0) {
                        alert(`éƒ¨åˆ†æ–‡ä»¶åˆ é™¤æˆåŠŸï¼Œä½†å­˜åœ¨ä»¥ä¸‹é”™è¯¯ï¼š\n${result.errors.join('\n')}`);
                    } else {
                        alert('æ–‡ä»¶åˆ é™¤æˆåŠŸ');
                    }
                    
                    selectedKbFiles.clear();
                    setKbEditMode(false);
                    await renderKnowledgeBase();
                    
                } catch (error) {
                    console.error('æ–‡ä»¶åˆ é™¤å¤±è´¥:', error);
                    alert('æ–‡ä»¶åˆ é™¤å¤±è´¥: ' + error.message);
                }
            };
        }
        if (refreshKbBtn) {
            refreshKbBtn.onclick = renderKnowledgeBase;
        }
        if (fileUpload) {
            fileUpload.addEventListener('change', async function(e) {
                const files = e.target.files;
                if (!files.length) return;

                const formData = new FormData();
                for (let file of files) {
                    formData.append('files[]', file, file.name);
                }

                try {
                    const response = await fetch('/api/knowledge/upload', {
                        method: 'POST',
                        body: formData
                    });

                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(errorData.error || 'ä¸Šä¼ å¤±è´¥');
                    }
                    
                    const result = await response.json();
                    if (result.error) throw new Error(result.error);
                    
                    alert('æ–‡ä»¶ä¸Šä¼ æˆåŠŸ');
                    await renderKnowledgeBase();
                } catch (error) {
                    console.error('æ–‡ä»¶ä¸Šä¼ å¤±è´¥:', error);
                    alert('æ–‡ä»¶ä¸Šä¼ å¤±è´¥: ' + error.message);
                }

                e.target.value = '';
            });
        }

        // æ–°å»ºå¯¹è¯æŒ‰é’®
        const newChatBtn = document.getElementById('new-chat-btn');
        if (newChatBtn) {
            newChatBtn.addEventListener('click', async () => {
                if (currentConversationId && chatState.messages.length > 0) {
                    try {
                        const lastMessage = chatState.messages[chatState.messages.length - 1];
                        const title = lastMessage.content.slice(0, 30) + (lastMessage.content.length > 30 ? '...' : '');
                        
                        await fetch(`/api/conversations/${currentConversationId}`, {
                            method: 'PUT',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ title: title })
                        });

                        await loadConversations();
                    } catch (error) {
                        console.error('ä¿å­˜å½“å‰å¯¹è¯å¤±è´¥:', error);
                    }
                }
                
                currentConversationId = null;
                chatState.messages = [];
                chatState.isActive = false;
                
                const chatMessages = document.getElementById('chat-messages');
                if (chatMessages) {
                    chatMessages.innerHTML = '';
                }
                
                if (questionInput) {
                    questionInput.value = '';
                }
                
                renderConversations();
                
                if (questionInput) {
                    questionInput.focus();
                }
            });
        }
    }

    // å¯¼å‡ºéœ€è¦çš„å‡½æ•°
    export {
        cleanWebPageNoise,
        cleanMarkdownHeadings,
        truncateMarkdownContent,
        processQuestion,
        displayResult,
        updateProgress,
        showStepContent,
        addChatMessage,
        switchConversation,
        renderConversations,
        loadConversations,
        renderHistory,
        setEditMode,
        renderHistoryControls,
        setKbEditMode,
        renderKnowledgeBase,
        initializeEventListeners
    };
}); 